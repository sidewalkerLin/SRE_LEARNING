### 一、Centos6启动管理

#### 1、BIOS

Basic Input and Output System（基本输入输出系统），**它是一段被固化在主板ROM中的程序**，掉电不会丢失，**其主要功能是为电脑提供最基本的输入输出功能、开机硬件自动检测、设置、初始化**。电脑按下开机之后，首先要做的就是加载并运行BIOS。

BIOS主要有三个功能：

- **加电自检（Power On Self Test）**

加电自检可以检查电脑硬件是否良好，常见标准是检查CPU、640KB基本内存、1M以上扩展内存、ROW、主板、CMOS存储器（CMOS RAM中存储着系统基本启动信息，是用来保存BIOS的配置和用户的设定参数，掉电不丢失数据）、显示卡、键盘等进行测试，一旦发现故障，就停机或报警，状态良好就进入下一个步骤。

- **初始化中断相关服务**

这个部分主要包括创建中断向量、设置寄存器等，值得注意的是在操作系统启动之后，BIOS还是继续存在的，提供硬件中断处理以及提供程序与IO设备的底层逻辑支持。不过最新的操作系统开始绕过BIOS提供的抽象接口，而选择直接与硬件进行交互。

- **加载引导程序**

这个部分就是加载引导操作系统，如DOS、Windows、Linux等。BIOS会根据CMOS RAM（可以看成是保存BIOS配置的存储器）中对存储设备（硬盘、U盘等）的排序，然后按照CMOS设置里的顺序，挨个查看存储设备的前512字节是不是**以0x55 0xAA结尾**，如果不是，那就跳过找下一个设备；如果是的话，则表示这个磁盘可以启动，加载这512字节里的代码，执行之后，后面的事，几乎就跟BIOS没啥关系了。

至于加载引导代码后面启动什么系统，取决于这512B（字节）里存了什么系统的代码。这个代码是各家系统安装程序写进去的，目的是启动自家系统。比如安装Windows，这里面就变成了Windows的启动代码；安装了Linux，这里面就会变成Grub的启动代码。

#### 2、MBR、DPT、PBR

前面提到BIOS加载引导程序时会依次检验存储设备前512Bytes的内容**，如果以0x55 0xAA结尾，则这个512Bytes的内容就是MBR**。当BIOS找到MBR之后，就会将计算机的控制权交给MBR，并运行其中的MBR代码。这512字节是磁盘的第一个逻辑扇区(**LBA0**)，其中MBR引导代码仅仅只占446字节。

<font color='#ff0000'> **MBR**</font>的组成分为3个部分：

- 1-446字节：MBR引导代码，用于加载操作系统的机器码。它的作用是在磁盘上找到grub程序并加载它。

- 447-510字节：

这64字节叫做MBR分区表或者磁盘分区表(<font color='#ff0000'> **DPT**</font>)，也就是下图中绿色分区表0、1、2、3。磁盘分区表的作用是来将硬盘分区，比如将一块磁盘分为几个区。因为一个磁盘分区需要占用16字节，所以最多只能分64/16=4个磁盘分区。

为什么一个分区需要占用16字节呢？因为一个分区的基本信息包括**引导标志(1个字节)、分区类型(1个字节)、分区起始位置(3个字节)、分区结束位置(3个字节)、分区容量(4个字节)、分区偏移量(4个字节)**，所以总共16字节。而磁盘分区表只有64字节，所以只能存储4个分区的基本信息。

**引导标志位若值为80H表示活动分区，若值为00H表示非活动分区**。**活动分区是指硬盘上存储操作系统引导程序的主分区或逻辑分区**。假入分区1的标志位为80H，那么分区1就是就是活动分区。那么MBR引导代码就会根据分区的引导标志位找到分区1，并且读取该分区最前面的<font color='#ff0000'> **分区引导记录PBR**</font>，PBR同样包含一段可运行的代码以及对应的**操作系统引导程序所在的位置**，也就是<font color='#ff0000'> **Bootloader**</font>(对于linux而言即grub)的位置。

- 511-512字节：即0x55和0xAA，用来标记这个扇区是MBR分区。

![image-20230824204210506](C:\Users\26926\AppData\Roaming\Typora\typora-user-images\image-20230824204210506.png)

PBR

包含了分区的基本信息，例如分区类型，文件系统类型，分区大小，逻辑块地址等

包含了一个引导代码，用于加载分区中的操作系统或者引导程序，例如NTLDR，GRUB，LILO等

它包含了一个结束标志，用于标识VBR的结束位置，通常是0x55AA

#### 3、Bootloader

bootloader是引导加载器，引导程序， 是底层硬件与上层应用软件(操作系统)之间的一个中间接口软件。 

它不是BIOS中的功能，也不是操作系统中的功能，它是一个独立的软件，运行在BIOS之后，操作系统启动之前。它的主要作用就是引导操作系统启动。

在windows中的bootloader是**ntloader**；在linux中的bootloader是**grub**。

#### 4、grub

grub的启动过程分为3阶段：

**1阶段：**

读取MBR分区中前446字节的引导代码。

由于文件系统是在操作系统之后加载，因此此阶段没有识别文件系统的能力，所以1阶段会尝试加载1.5阶段。

1阶段通过分区表中的标记位来找到活动分区，来加载活动分区前面的分区引导记录PBR(也称卷引导记录VBR)，来进入1.5阶段。

**1.5阶段：**

1.5阶段位于活动分区的PBR中，PBR可以识别活动分区(也就是/boot分区)文件系统，加载PBR中的引导代码来读取分区内操作系统程序和grub程序的位置，加载grub程序进入2阶段。

**2阶段：**

(1)解析GRUB程序的配置文件grub.cfg

(2)依据配置文件决定是否显示系统启动菜单

(3)加载内核镜像到内存中并设置好内核的启动参数

(4)通过**initramfs.img**程序建立RAMDisk内存虚拟根文件系统

(5)将内核控制权转交给init程序

这里的细节说明一下：

**首先我们需要知道的是，加载一个文件系统，必须由该文件系统的驱动来完成。initramfs.img是一个临时的根文件系统，是一个精简版的linux系统，initramfs.img中包含了一些通用的文件系统驱动程序。grub在将内核镜像加载到内存之后，内核会加载initramfs.img到内存中并解压，并将initramfs.img作为临时的根文件系统(注意并未将initramfs.img挂载在根分区上)，然后会执行initramfs.img中的init程序。**

**initramfs.img中的init程序执行的步骤如下：**

1. **检测和初始化硬件设备。这可能包括加载设备驱动，初始化网络服务，等等。**
2. **挂载真正的根文件系统。initramfs.img中会创建一个临时的目录，例如/mnt，然后将其作为真的根文件系统的挂载节点。其中，init脚本需要确定包含根文件系统的设备，这可能涉及到硬件检测和设备驱动的加载，然后使用mount命令将这个设备挂载到临时的挂载点上。**
3. **切换到真正的根文件系统。这是通过switch_root命令完成的。switch_root会将当前的根文件系统（即initramfs）移动到一个临时目录，然后将新的根目录（即真正的根文件系统）移动到根目录（/）。**
4. **执行新的init程序，用exec命令来让新的init程序代替当前进程的init，成为pid为1的进程。这通常是真正根文件系统中的/sbin/init程序。这个新的init程序将接管系统，开始执行各种启动脚本，启动各种服务，等等。**

**当内核在加载完真正的根文件系统后，系统会开始使用内核中的文件系统驱动。在新的init程序替代旧的init程序后，就会卸载并释放initramfs.img所占用的内存，包括其中的文件系统驱动。**



**总结一下就是：initramfs.img是一个精简版的linux系统，也就是一个根文件系统，其中包含着一些常用的驱动程序。当grub加载内核镜像后，内核会加载initramfs.img到内存中并解压，并将其作为根文件系统，然后执行init程序，这个时候内核的控制权都移交给init程序处理。initramfs.img的init程序会将真正的根文件系统挂载到根分区上，然后通过switch_root命令切换到真正的根文件系统，然后用exec命令来让新的init程序代替当前进程的init，这个新的init程序将接管系统，开始执行各种启动脚本，启动各种服务，等等。**

#### 5、init初始化

**(1)init运行级别**：为系统运行或维护等目的而设定；0-6：7个级别，一般使用3, 5做为默认级别。在`/etc/inittab`文件可以定义运行级别。

| 运行级别 | 说明                                              |
| -------- | ------------------------------------------------- |
| 0        | 关机                                              |
| 1        | 单用户模式(root自动登录), 维护模式                |
| 2        | 多用户模式，启动网络功能，但不会启动NFS；维护模式 |
| 3        | 多用户模式，正常模式；文本界面                    |
| 4        | 预留级别；可同3级别                               |
| 5        | 多用户模式，正常模式；图形界面                    |
| 6        | 重启                                              |

**(2)sysinit初始化脚本**

sysinit初始化脚本包含以下功能：

1. 设置主机名 
2. 设置欢迎信息 
3. 激活udev和selinux 
4.  挂载/etc/fstab文件中定义的文件系统 
5. 检测根文件系统，并以读写方式重新挂载根文件系统 
6. 设置系统时钟 
7. 激活swap设备 
8. 根据/etc/sysctl.conf文件设置内核参数 
9.  激活lvm及software raid设备 
10. 加载额外设备的驱动程序 
11.  清理操作

**(3)服务管理**

在sysinit初始化初始化完成之后，init进程会根据`/etc/inittab`文件中定义的init默认运行级别，运行对应的`/etc/rc.d/rc*.d/`目录下的启动脚本，以启动各种系统服务。例如，如果默认运行级别是3，那么init进程会运行`/etc/rc.d/rc3.d/`目录下的所有S开头的脚本。

`/etc/rc.d/rc*.d/`里面分别保存着对应init运行级别的服务启动或关闭的脚本。比如rc0.d下的脚本会在关机时执行，比如rc3.d下的脚本会在init初始化且init级别被定义为3的时候执行。

这些目录中脚本的命名方式是，以S或K开头，分别代表启动(Start)和停止(Kill),后面跟着的数字表示启动或停止的顺序。例如S10network表示在系统启动时，network服务是第10个启动的服务。

**另外，需要注意的是：**

**假如当init进程的运行级别设定为3，init初始化时，init进程只会执行`/etc/rc.d/rc3.d/`目录下的所有S开头的脚本，并不会执行该目录下K开头的脚本，这些K开头的脚本只会在系统从运行级别3切换到其他运行级别时会被执行。比如你希望将系统切换到运行级别1(单用户式)，那么在切换过程中，init进程会首先运行`/etc/rc.d/rc3.d/`目录下的所有K开头的脚本，以停止运行级别3特有的服务。然后，init进程会运行`/etc/rc.d/rc1.d/`目录下的所有S开头的脚本，以启动运行级别1特有的服务。**

**另外只要你执行了关机或重启的操作，那么init进程就是执行对应的rc0.d或rc6.d下面的所有脚本，而不是去执行比如rc1.d、rc3.d下K开头的脚本。**

**`/etc/rc.d/rc*.d/`中所有脚本文件都是软连接到`/etc/init.d/`下的文件。**

以上过程是通过/etc/rc.d/rc脚本实现的。

**(4)开机启动文件rc.local**

rc.local文件是一个用于在系统启动时自动执行命令的脚本，可以在此脚本文件中添加开机希望启动的命令。

比如在rc.local中添加sleep 100的命令，可以在开机启动查看到sleep的进程，还可以添加nginx启动的命令实现你滚下开机自启，等等。

注意：

centos7之后由于systemd的出现，一般不再被使用；

在Ubuntu中默认不存在rc.local文件，可以自己创建，路径为/etc/rc.local。且此文件中必须加入shebang机制并添加可执行权限。

#### 6、Centos6启动过程总结

**第一步：POST加电自检**

**第二步：grub(bootloader)引导:**

grub1阶段：加载MBR分区前446字节的引导代码，根据MBR分区表的标志位找到活动分区，并加载1.5阶段；

grub1.5阶段：加载活动分区中的卷引导记录，提供识别活动分区文件系统的功能，类似于文件驱动，并加载2阶段；

grub2阶段：加载配置文件grub.cfg,显示系统启动的菜单，然后加载内核文件的镜像到内存中，传递一些启动参数给内核，并将控制权转给内核。

**第三步：内核引导**

内核将initramfs.img加载到内存中并加压并将其作为临时的根文件系统，然后执行其中的init脚本，挂载真正的根文件系统并切换到真正的文件系统，然后让新的init程序替代当前的init程序。

**第四步：init初始化**

(1)切换到配置的运行级别

(2)执行sysinit脚本

(3)执行/etc/rc.d/rc脚本来完成服务管理

### 二、systemd和启动流程

#### 1、内核如何找到systemd程序执行的？

内核和init程序是不同团队开发的，那么内核怎么知道运行systemd还是init呢？实际上都是执行的init程序，自不过centos7以后版本是将init软连接到systemd。

#### 2、systemd新特性

以下内容大量参考了这边文章：

```bash
https://yifengyou.github.io/learn-systemd/docs/systemd%E7%89%B9%E7%82%B9.html
```

**特性一：系统引导时实现服务并行启动**

在centos5中，SysVinit程序在开机启动时是串行的启动服务，一个服务启动完后才回去启动另一个服务；

在centos6中，Upstart程序在系统启动时会并行的启动服务，但是如果服务之间存在依赖关系，比如服务A依赖于B的，那么A和B无法并行启动，A服务只能在B服务启动就绪后才能启动。即使如此，相对于SysVinit，也大大减少了系统启动的时间。

在centos7中，systemd并行启动服务，相对于Upstart来说，systemd并行化启动服务的程度更高。即便对于那些 UpStart 认为存在相互依赖而必须串行的服务，systemd也会采取并发启动的形式。

**特性二：按需启动守护进程**

何为按需启动守护进程？systemd的按需启动主要通过socket激活和D-Bus激活两种方式实现。

socket是一种在操作系统中用于进程间通信的机制。它可以是网络socket(例如TCP或UDP端口)，也可以是UNIX域socket(一个在本地系统中的进程间通信机制)。

systemd在系统启动时会创建一些socket，但并不立即启动与这些socket关联的服务。当有数据发送到这些socket时，systemd会自动启动相应的服务来处理这些数据。这样，只有当服务真正需要处理数据时，服务才会被启动。

例如，一个网络服务可能有一个关联的TCP端口，systemd会在系统启动时打开这个端口，但并不立即启动这个网络服务。只有当有数据发送到这个端口时，systemd才会启动这个网络服务来处理数据。

**特性三：自动化的服务依赖关系管理**

系统启动过程是由很多的独立工作共同组成的，这些工作之间可能存在依赖关系，比如挂载一个 NFS 文件系统必须依赖网络能够正常工作。Systemd 虽然能够最大限度地并发执行很多有依赖关系的工作，但是类似”挂载 NFS”和”启动网络”这样的工作还是存在天生的先后依赖关系，无法并发执行。对于这些任务，systemd 维护一个”事务一致性”的概念，保证所有相关的服务都可以正常启动而不会出现互相依赖，以至于死锁的情况。

**特性四：同时采用socket式与D-Bus总线式激活服务**

**特性五：socket与服务程序分离**

**特性六：向后兼容sysv init脚本**

Systemd 是一个"新来的"，Linux 上的很多应用程序并没有来得及为它做相应的改变。和 UpStart 一样，systemd 引入了新的配置方式，对应用程序的开发也有一些新的要求。

如果 systemd 想替代目前正在运行的初始化系统，就必须和现有程序兼容。

任何一个 Linux 发行版都很难为了采用 systemd 而在短时间内将所有的服务代码都修改一遍。

Systemd 提供了和 Sysvinit 以及 LSB initscripts 兼容的特性。系统中已经存在的服务和进程无需修改。这降低了系统向 systemd 迁移的成本，使得 systemd 替换现有初始化系统成为可能。

**特性七：systemd采用Linux的Cgroup的特性跟踪和管理进程的生命周期**

init 系统的一个重要职责就是负责跟踪和管理服务进程的生命周期。它不仅可以启动一个服务，也必须也能够停止服务。这看上去没有什么特别的，然而在真正用代码实现的时候，您或许会发现停止服务比一开始想的要困难。

服务进程一般都会作为精灵进程（daemon）在后台运行，为此服务程序有时候会派生(fork)两次。在 UpStart 中，需要在配置文件中正确地配置 expect 小节。这样 UpStart 通过对 fork 系统调用进行计数，从而获知真正的精灵进程的 PID 号。比如图 3 所示的例子：

图 3. 找到正确 pid 找到正确 pid 如果 UpStart 找错了，将 p1`作为服务进程的 Pid，那么停止服务的时候，UpStart 会试图杀死 p1`进程，而真正的 p1``进程则继续执行。换句话说该服务就失去控制了。

还有更加特殊的情况。比如，一个 CGI 程序会派生两次，从而脱离了和 Apache 的父子关系。当 Apache 进程被停止后，该 CGI 程序还在继续运行。而我们希望服务停止后，所有由它所启动的相关进程也被停止。

为了处理这类问题，UpStart 通过 strace 来跟踪 fork、exit 等系统调用，但是这种方法很笨拙，且缺乏可扩展性。systemd 则利用了 Linux 内核的特性即 CGroup 来完成跟踪的任务。当停止服务时，通过查询 CGroup，systemd 可以确保找到所有的相关进程，从而干净地停止服务。

CGroup 已经出现了很久，它主要用来实现系统资源配额管理。CGroup 提供了类似文件系统的接口，使用方便。当进程创建子进程时，子进程会继承父进程的 CGroup。因此无论服务如何启动新的子进程，所有的这些相关进程都会属于同一个 CGroup，systemd 只需要简单地遍历指定的 CGroup 即可正确地找到所有的相关进程，将它们一一停止即可。

**特性八：系统状态快照**

systemd 支持按需启动，因此系统的运行状态是动态变化的，人们无法准确地知道系统当前运行了哪些服务。Systemd 快照提供了一种将当前系统运行状态保存并恢复的能力。

比如系统当前正运行服务 A 和 B，可以用 systemd 命令行对当前系统运行状况创建快照。然后将进程 A 停止，或者做其他的任意的对系统的改变，比如启动新的进程 C。在这些改变之后，运行 systemd 的快照恢复命令，就可立即将系统恢复到快照时刻的状态，即只有服务 A，B 在运行。一个可能的应用场景是调试：比如服务器出现一些异常，为了调试用户将当前状态保存为快照，然后可以进行任意的操作，比如停止服务等等。等调试结束，恢复快照即可。

这个快照功能目前在 systemd 中并不完善，似乎开发人员也没有特别关注它，因此有报告指出它还存在一些使用上的问题，使用时尚需慎重。

**特性九：日志服务**

systemd 自带日志服务 journald，该日志服务的设计初衷是克服现有的 syslog 服务的缺点。比如：

syslog 不安全，消息的内容无法验证。每一个本地进程都可以声称自己是 Apache PID 4711，而 syslog 也就相信并保存到磁盘上。 数据没有严格的格式，非常随意。自动化的日志分析器需要分析人类语言字符串来识别消息。一方面此类分析困难低效；此外日志格式的变化会导致分析代码需要更新甚至重写。 Systemd Journal 用二进制格式保存所有日志信息，用户使用 journalctl 命令来查看日志信息。无需自己编写复杂脆弱的字符串分析处理程序。

Systemd Journal 的优点如下：

- 简单性：代码少，依赖少，抽象开销最小。
- 零维护：日志是除错和监控系统的核心功能，因此它自己不能再产生问题。举例说，自动管理磁盘空间，避免由于日志的不断产生而将磁盘空间耗尽。
- 移植性：日志 文件应该在所有类型的 Linux 系统上可用，无论它使用的何种 CPU 或者字节序。
- 性能：添加和浏览日志非常快。
- 最小资源占用：日志数据文件需要较小。
- 统一化：各种不同的日志存储技术应该统一起来，将所有的可记录事件保存在同一个数据存储中。所以日志内容的全局上下文都会被保存并且可供日后查询。例如一条固件记录后通常会跟随一条内核记录，最终还会有一条用户态记录。重要的是当保存到硬盘上时这三者之间的关系不会丢失。Syslog 将不同的信息保存到不同的文件中，分析的时候很难确定哪些条目是相关的。
- 扩展性：日志的适用范围很广，从嵌入式设备到超级计算机集群都可以满足需求。
- 安全性：日志 文件是可以验证的，让无法检测的修改不再可能。

#### 3、systemd中的Unit

在systemd中，"unit"是一个基本的概念，它代表了系统的一个组件。每个unit都对应一个配置文件，这个文件描述了这个组件的行为。

**(1)unit有很多类型**

```bash
#通过此命令可以查询unit的类型
root@Ubuntu22:~# systemctl -t help
Available unit types:
service  
mount 
swap     
socket
target	  
device	   
automount  
timer 	   
path	  
slice      
scope      
```

**(2)unit类型说明**

| unit类型  | 文件后缀   | 作用                                                         |
| --------- | ---------- | ------------------------------------------------------------ |
| service   | .service   | 定义系统服务                                                 |
| socket    | .socket    | 定义进程间通信用的socket文件，可以延迟启动，按需启动         |
| target    | .target    | 不同服务的集合，用于模拟init运行级别                         |
| device    | .device    | 用于定义内核识别的设备                                       |
| mount     | .mount     | 定义文件系统挂载点                                           |
| automount | .automount | 文件系统的自动挂载点                                         |
| swap      | .swap      | 用于标识swap设备                                             |
| timer     | .timer     | 用于安排激活另一个单元的计时器                               |
| path      | .path      | 用于定义文件系统中的文件或目录，常用于当文件系统变化时， 延迟激活服务，如spool 目录 |
| slice     | .slice     | 通过 Linux 控制组节点 (cgroups) 限制资源                     |
| scope     | .scope     | systemd 总线接口的信息，常用于管理外部系统进程               |

**(3)unit文件路径**

```bash
#俩个路径，软连接
/lib/systemd/system/
/usr/lib/systemd/system/

[20:38:55 root@rocky86 ~]#ll /lib
lrwxrwxrwx. 1 root root 7 Oct 11  2021 /lib -> usr/lib
```

**(4)unit文件结构**

```bash
#nginx.service示例
[Unit]
Description=The nginx HTTP and reverse proxy server
After=network.target remote-fs.target nss-lookup.target

[Service]
Type=forking
PIDFile=/run/nginx.pid
ExecStartPre=/usr/bin/rm -f /run/nginx.pid
ExecStartPre=/usr/sbin/nginx -t
ExecStart=/usr/sbin/nginx
ExecReload=/bin/kill -s HUP $MAINPID
KillSignal=SIGQUIT
TimeoutStopSec=5
KillMode=mixed
PrivateTmp=true

[Install]
WantedBy=multi-user.target
```

在nginx.service的示例中，Systemd 服务的 Unit 文件可以分为三个配置区段：Unit、Service、Install。其中，Unit和Install配置段所有unit文件通用。而Service段却是和unit文件类型有关，比如在nginx.service中写为Service；在docker.socket中，这个段写成Sokcet。

```bash
#Unit段
Description   #描述这个 Unit 文件的信息
Documentation #指定服务的文档，可以是一个或多个文档的 URL 路径
Requires      #定义了一种强依赖关系，启动当前服务时，systemd会先启动指定的依赖服务，如依赖服务启动失败则当前单元无法启动
Wants         #定义了一种弱依赖关系，如果wants的服务启动失败，当前服务仍然启动
After         #定义启动顺序，在启动当前服务前会尝试启动after指定的服务，无论after指定的服务是否启动成功，都会启动当前服务。注意这里需要区别于启动顺序和依赖关系，启动顺序是不会对当前服务造成影响的，而强依赖关系会。
Before        #定义启动顺序，在启动当前服务后会尝试启动before指定的服务
Binds To      #定义了一种强关联关系，如果关闭Binds To指定的服务，那么当前服务也会被关闭
Part Of       #定义了一种属于关系
OnFailure     #定义了一种失败处理机制
Conflicts     #定义了一种冲突关系，如果Conflicts指定的服务启动时，当前服务会被关闭
```

```bash
#Service段
Type
Type=simple    #默认值，执行ExecStart指定的命令，启动主进程
Type=forking   #以fork方式从父进程创建子进程，创建后父进程会立即退出。通常用于那些需要在后台运行的服务
Type=oneshot   #服务在启动后会执行一次然后退出，不会常驻后台。这种类型的服务通常用于一次性的任务，比如系统启动时的初始化任务
Type=dbus      #当前服务通过D-Bus启动
Type=notify    #当前服务启动完毕，会通知Systemd，再继续往下执行。这种类型的服务通常用于那些需要在启动完成后立即提供服务的程序
Type=idle      #若有其他任务执行完毕，当前服务才会运行

RemainAfterExit  #
ExecStart        #启动当前服务的命令
ExecStartPre 	 #启动当前服务之前执行的命令
ExecStartPos	 #启动当前服务之后执行的命令
ExecReload		 #重启当前服务时执行的命令
ExecStop		 #停止当前服务时执行的命令
ExecStopPost 	 #停止当其服务之后执行的命令
RestartSec		 #自动重启当前服务间隔的秒数
Restart			 # 定义何种情况 Systemd 会自动重启当前服务
TimeoutStartSec  #启动服务时等待的秒数
TimeoutStopSec	 #停止服务时的等待秒数

Environment      #为服务指定环境变量
EnvironmentFile	 #指定加载一个包含服务所需的环境变量的列表的文件，文件中的每一行都是一个环境变量的定义
Nice			 #服务的进程优先级，值越小优先级越高，默认为 0。其中 -20 为最高优先级，19 为最低优先级
WorkingDirectory #指定服务的工作目录
RootDirectory    #定服务进程的根目录，如果配置了这个参数，服务将无法访问指定目录以外的任何文件
User			 #
Group			 #
MountFlags		 #
LimitCPU / LimitSTACK / LimitNOFILE / LimitNPROC #限制特定服务的系统资源量，例如CPU、程序堆栈、文件句柄数量、子进程数量
```

#### 4、systemd中的运行级别

这里target文件是不同服务的集合，类似于rc*.d，用于模拟init运行级别

```bash
root@Ubuntu22:~# ll /lib/systemd/system/*.target
...
lrwxrwxrwx 1 root root  15 Mar  2  2023  /lib/systemd/system/runlevel0.target -> poweroff.target   #关机
lrwxrwxrwx 1 root root  13 Mar  2  2023  /lib/systemd/system/runlevel1.target -> rescue.target #救援、单用户
lrwxrwxrwx 1 root root  17 Mar  2  2023  /lib/systemd/system/runlevel2.target -> multi-user.target #多用户
lrwxrwxrwx 1 root root  17 Mar  2  2023  /lib/systemd/system/runlevel3.target -> multi-user.target
lrwxrwxrwx 1 root root  17 Mar  2  2023  /lib/systemd/system/runlevel4.target -> multi-user.target
lrwxrwxrwx 1 root root  16 Mar  2  2023  /lib/systemd/system/runlevel5.target -> graphical.target #图形界面
lrwxrwxrwx 1 root root  13 Mar  2  2023  /lib/systemd/system/runlevel6.target -> reboot.target #重启
...
```

### 三、进程管理

#### 1、什么是进程？与程序的区别是什么？

进程是正在运行中的程序，也就是一个运行的程序的实例，相对于程序来说，进程是一个动态的概念，而程序是一个静态的概念。

程序是一个静态的概念，它是存储在磁盘上的一组指令。

进程是程序的动态执行过程，它有自己的生命周期，包括创建、调度执行、等待、结束等状态。

#### 2、进程的组成

(1)进程控制块PCB



(2)数据段



(3)程序段



#### 3、进程的创建

在Linux系统中，除了系统的第一个进程（通常是systemd或init）是由内核在系统启动时创建的，其他**所有进程都是由一个已存在的父进程通过fork()或clone()等系统调用创建的**。

这个父进程可以是任何已经存在的进程，例如shell、systemd、或者其他服务进程。新创建的进程（子进程）会继承父进程的一些属性，然后可以通过调用exec()系列函数来加载并执行一个新的程序。

这种模型使得Linux系统可以通过一个简单的机制来创建和管理进程，同时也支持了进程间的隔离和并发执行。

#### 4、进程的并发执行与并行执行

**并发执行**：是指在一段时间内，有多个进程在同一CPU上运行，但是在任何一个瞬间，只有一个进程在CPU上运行，并发执行并不代表着CPU将不同的进程同时执行。

实际上，操作系统的调度器会将CPU的时间分割为很小的片段，这种片段称为时间片，时间片是非常小的，小到时间片段人类几乎感知不到。调度器会根据特定的调度算法（如轮转调度、优先级调度、最短作业优先等）来决定哪个进程获得CPU的使用权以及每个进程的时间片长度。

在某个时间片里面只会有1个进程被执行，假如调度器将20ms分割为10个时间片，每个时间片执行一个进程，那么在20ms里面就有10个进程执行成功，因为20ms人类几乎是无感知的，所以在人类的感知中这些进程就是同时被处理的，实际上不然，这10个进程是顺序执行的，而这就是并发执行。

**并行执行**：是指在同一时刻，有多个进程在多个CPU上同时运行。在同一时间点，单个CPU只能执行单个进程，但是如果存在多个CPU，那么在同一时间点，每个CPU都执行一个进程，那么就有多个进程同时在被执行，这就是并行执行。

#### 5、进程的上下文切换



#### 6、进程的状态



#### 7、进程的调度与优先级



#### 8、进程的通信



### 四、线程管理



### 五、内存管理





### 六、进程相关工具

#### 1、<font color='#ff0000'> **pstree**</font>

pstree 可以用来显示进程的父子关系，以树形结构显示

```bash
pstree -p     #树状显示进程关系
pstree mysql  #显示mysql这个用户启动了哪些进程

```



#### 2、<font color='#ff0000'> **ps**</font>

ps可以查看进程当前状态的快照，默认显示当前终端中的进程

```bash
命令格式：
ps [options]

#常用选项
a      #选项包括所有终端中的进程
u      #选项包括不链接终端的进程
x      #选项显示进程所有者的信息
f

```



#### 3、prtstat





#### 4、pgrep



#### 5、<font color='#ff0000'> **pidof**</font>



#### 6、<font color='#ff0000'> **uptime**</font>



#### 7、 mpstat



#### 8、<font color='#ff0000'> **top**</font>





#### 9、htop





#### 10、<font color='#ff0000'> **free**</font>





#### 11、pmap





#### 12、vmstat



#### 13、iostat



#### 14、iotop



#### 15、iftop



#### 16、nload





#### 17、nethogs





#### 18、iptraf-ng



#### 19、dstat



#### 20、glances



#### 21、<font color='#ff0000'> **lsof**</font>





#### 22、cockpit



#### 23、<font color='#ff0000'> **kill**</font>



### 七、计划任务

1、
