### 一、网络分层与数据传输

#### 1、网络模型分层

在互联网上，网络分层模型有3种：TCP/IP四层模型、五层模型、OSI七层模型。

实际上在，在早期的生产环境中用的就是TCP/IP四层模型并且一直沿用至今。ISO 推出的 OSI 的七层模型是后来才提出来的，可能是为了规范化把，但是实际上OSI七层模型并没有如愿的普及开来，生产环境中还是使用的TCP/IP四层模型，所以现在七层模型其实就是用来辅助人们理解网络的分层。

而五层模型是综合了TCP/IP四层模型和OSI七层模型得到的，它的出现也是为了方便人民学习计算机网络原理而采用的，学习用的。

![image-20230921145055520](C:\Users\26926\AppData\Roaming\Typora\typora-user-images\image-20230921145055520.png)

#### 2、数据在网络中的传输

##### 2.1、协议数据单元PDU

<font color='#ff0000'> **协议数据单元PDU是指对等层次之间传递的数据单位。**</font>

- 物理层的PDU是数据位(bit)
- 数据链路层的PDU是数据帧(frame)
- 网络层的PDU是数据包(packet)
- 传输层的PDU是数据段(segment)
- 应用层的PDU是数据(data)

##### 2.2、数据的封装过程

应用层的数据需要进行层层封装才能在互联网中通过比特流进行传输，到达目的主机后再进行层层的解封装，最后由目的主机的应用读取来源主机应用的数据。

![image-20230921115433741](C:\Users\26926\AppData\Roaming\Typora\typora-user-images\image-20230921115433741.png)

##### 2.3、单播、广播、多播、组播

单播：一对一的通信方式，数据由一台设备发出，最后由一台设备接收，接收方只有1个。

广播：一对所有的通信方式，数据由一台设备发出，网络中的所有设备都会接收到数据，接收方是网络中的所有主机。

多播：一对多的通信方式，数据由一台设备发出，网络中的多个设备会收到数据，接收方是网络中的部分主机。多播可以在2层多播，也就是MAC多播，比如ARP协议；也就可以在3层多播，也就是IP多播。

组播：一种特定多播形式，属于是多播的子集。它将数据包发送到一个组，这个组包含了所有需要接收这个数据包的节点。组播通常在网络层进行，使用IP多播地址来标识目标组。组播的主要应用是在大型网络环境中，如互联网电视(IPTV)和视频会议等。

##### 2.4、冲突域、广播域

冲突域：两个网络设备同时发送数据，如果发生了冲突，则两个设备处于同一个冲突域，反之，则各自处于不同 的冲突域。

广播域：一个网络设备发送广播，另一个设备收到了，则两个设备处于同一个广播域，反之，则各自处于不同的 广播域。

在现代网络中，冲突域已经大大减少，这主要是因为现代网络设备（如交换机）的使用。交换机可以在其端口之间建立专用的通信路径，从而使每个端口都成为一个单独的冲突域。这与早期的网络设备（如集线器）不同，集线器会将所有端口放在同一个冲突域中。

此外，现代网络设备通常支持全双工通信，这意味着设备可以同时发送和接收数据，从而进一步减少冲突的可能性。全双工通信不会产生冲突，因为发送和接收是在不同的信道上进行的。

##### 2.5、单工、半双工、全双工

单工通信：只有一个方向的通信

半双工通信：通信双方都可以发送和接收信息，但不能同时发送，也不能同时接收。可以理解为同一时时只有一个设备在发送数据，其它设备只能监听

全双工通信：通信双方可以同时发送和同时接收

### 三、TCP协议

#### 1、TCP首部的结构

TCP头部包含20字节固定头部以及长度可变的其它选项(最多40字节)，所以TCP头部的长度(最多60字节)是可变的。如下图所示，TCP头部固定的20字节可以分为 5部分，也就是图中的5行，每行各占32位，也就是4字节。

![image-20230921192615927](C:\Users\26926\AppData\Roaming\Typora\typora-user-images\image-20230921192615927.png)

**源端口、目标端口：**

俩个端口各占2字节，端口是用来实现应用层和传输层通信的。源端口是由客户端主机随机分配的，而目标端口通常是预定义好的。

什么是预定义好的？

比如ssh默认是22端口，http默认是80....等等，这些协议对应的端口都是预定义好的。应用层在将预定义好的目的端口传给传输层，传输层再将其封装到TCP头部中。

**序号：**

<font color='#ff0000'> **以下提到的字节数都是指的应用层的数据，不包括TCP头部**</font>

TCP会对传送的数据流中的每个字节进行编号，而序号则是每个数据段中**应用层部分数据**的第一个字节。

怎么理解序号呢？

假如我们要传输一个大文件，是不可能将其全量数据封装在一起进行传输的，这样的效率十分慢。所以，在网络中，往往是将文件切成更小的单元进行传输，这个单元的大小取决于当时网络情况，以优化性能。而在传输过程中，因为网络情况差异、数据大小等差异造成到达目的主机的时候数据单元的顺序已经被打乱了，那么，序号的存在就可以这些数据单元顺序的串联起来。

**特别注意的是，发送方的序号和接收方的序号是各自独立的，这俩个没有任何的计算关系，俩边的初始序号值都是随机的，然后再根据各自携带的应用层数据的字节数来填写**。

序号是怎么取值的？

第一个切分的数据单元的序号是一个随机的初始值，以增加TCP连接的安全性。假如一个文件切分为了3个单元，第一个单元100字节，第二个单元200字节，第三个单元50字节。第一个单元会有初始的序号，假如这个值是10，那么第一个单元最后那个序号就是10+100-1=109。那么第二个单元的序号就是第二个单元第一个字节的序号109+1=110，第二个单元最后一个字节的序号就是110+200-1=309。第三个单元的序号就是第三个单元第一个字节的序号309+1=310。

**确认号：**

确认号用于给接收方发送`发送方期望收到的字节序号`。

同一个TCP头中，确认号与序号是无关的，它与建立连接的对方的序号有关。

举个例子，客户端给服务端发送一个数据包A后，服务端会回复一个数据包B。A和B中都有序号和确认号这俩个字段，B中的确认号是跟A中的序号有关；而A中的确认号跟B中的序号有关。作为服务端，我收到了客户端A包中若干字节的数据，那我肯定要返回我期望收到的下一字节序号，这个序号就是B包中的确认号。反过来，作为客户端，我收到了服务端回复的B包中的若干字节的数据，我肯定要返回我期望收到的下一字节序号，这个序号就是A包中的确认号。如果时客户端第一次发，那么确认号可能为空或者特殊值，因为它还没有收到过服务端的数据。

**数据偏移：**

占4bit，也就是0.5个字节。它指出 TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远，也就是TCP首部的长度。

**保留：**

占 6 bit，保留为今后使用，现在还用不到，先把位置保留着，所以目前是设置为 0，总的来说就是没啥用，不用管他。

**URG：**

表示本报文段中发送的数据是否包含紧急数据。后面的紧急指针字段只有当URG=1时才有效。

**ACK：**

ACK是对已接受数据的确认，确认前面确认号字段是否有效。只有当ACK=1时，前面的确认号字段才有效。TCP规定，连接建立后，ACK必须为1,带ACK标志的TCP报文段称为确认报文段。如果是客户端对服务端的第一次请求，那么ACK=0，确认号是无效的，因为客户端还没有受到过服务端的数据。

**PSH：**

提示接收端应用程序应该立即从TCP接收缓冲区中读走数据，为接收后续数据腾出空间。如果为1，则表示对方应当立即把数据提交给上层应用，而不是缓存起来，如果应用程序不将接收到的数据读走，就会一直停留在TCP接收缓冲区中。

**RST：**

如果收到一个RST=1的报文，说明与主机的连接出现了严重错误（如主机崩溃），必须释放 连接，然后再重新建立连接。或者说明上次发送给主机的数据有问题，主机拒绝响应，带RST标志 的TCP报文段称为复位报文段。

**SYN：**

在建立连接时使用，用来同步序号。当SYN=1，ACK=0时，表示这是一个请求建立连接的报 文段；当SYN=1，ACK=1时，表示对方同意建立连接。SYN=1，说明这是一个请求建立连接或同意 建立连接的报文。只有在前两次握手中SYN才置为1，带SYN标志的TCP报文段称为同步报文段。

**FIN：**

表示通知对方本端要关闭连接了，标记数据是否发送完毕。如果FIN=1，即告诉对方：“我的数据已经发送完毕，你可以释放连接了”，带FIN标志的TCP报文段称为结束报文段。

**窗口：**

表示现在允许对方发送的数据量，也就是告诉对方，从本报文段的确认号开始允许对方发送的数据量，达到此值，需要ACK确认后才能再继续传送后面数据，由Window size value *  Window size scaling factor（此值在三次握手阶段TCP选项Window scale协商得到）得出此值

**检验和：**

检验和字段检验的范围包括首部和数据这两部分。在计算检验和时，要在 TCP 报文段的前面加上 12 字节的伪首部。提供额外的可靠性。

**紧急指针：**

标记紧急数据在数据字段中的位置。

**可变选项：**

窗口扩大选项、时间戳选项、选择确认选项等。

**填充：**

这是为了使整个首部长度是 4 字节的整数倍。

#### 2、TCP三次握手

a、客户端发送一个SYN包给服务端，表示希望建立连接，此时客户端由CLOSED状态变为SYN-SENT状态

b、服务端收到SYN包后，会回复一个SYN+ACK包给客户端，确认客户端的连接，此时服务端进入SYN-RCVD状态

c、客户端收到服务端的SYN+ACK包后，会发送一个ACK包给服务端，确认服务端的连接请求，此时客户端进入ESTABLISHED状态

d、服务端收到客户端的ACK包后，也进入ESTABLISHED状态

![image-20230922181100057](C:\Users\26926\AppData\Roaming\Typora\typora-user-images\image-20230922181100057.png)

<font color='#ff0000'> **问题：为什么是3次握手？而不是2次握手或4次握手？**</font>

**(1)为什么不是2次握手？**

第一个方面：

要想达到可靠传输，双方都需要确认对方有基本的接收数据的能力和发送数据的能力

第一次握手在客户端向服务端发送请求后。服务端可以确认**客户端发送数据的能力和服务端接收数据的能力**是正常的

第二次握手在服务端在回复客户端一个确认请求后，客户端可以确认**服务端发送数据的能力和客户端接收数据的能力**是正常的

这个时候，服务端不能确认客户端接收数据的能力是否正常，以及服务端自己发送数据的能力是否正常，所以需要第三次的握手。

第二个方面：

如果TCP连接采用2次握手，那么如果在建立连接后，客户端发送给服务端的报文段因为网络原因延迟了，并在TCP连接断开以后才到达服务端，那么服务端会认为客户端是在向自己请求建立连接，于是向客户端发送一个确认的报文，这样就建立了一个失效的连接。

而在三次握手中，即使服务端收到了延迟的连接请求报文段，也不会立即建立连接，而是会向客户端发送确认。如果客户端没有发起新的连接请求，那么它就会忽略这个确认，因此不会建立错误的连接。

**(2)为什么不是4次握手？**

可以但没有必要，浪费资源。

#### 3、TCP四次挥手

TCP的四次挥手过程是用来终止一个已经建立的TCP连接，<font color='#ff0000'> **客户端和服务端都可以来主动关闭这个连接**</font>。

a、当主动关闭连接的一方（假设是客户端）决定关闭连接时，它会发送一个FIN报文给另一方（服务端）。这个FIN报文表示客户端已经没有数据要发送了。发送完FIN报文后，客户端进入FIN-WAIT-1状态。

b、服务端收到FIN报文后，会发送一个ACK报文给客户端，确认已经收到了FIN报文。然后服务端进入CLOSE-WAIT状态。这个状态表示服务端已经知道客户端没有数据要发送了，但是服务端可能还有数据要发送。

c、客户端收到服务端的ACK报文后，进入FIN-WAIT-2状态。在这个状态下，客户端等待服务端发送它的FIN报文。

d、当服务端发送完所有数据后，它会发送一个FIN报文给客户端，表示服务端也没有数据要发送了。然后服务端进入LAST-ACK状态。

e、客户端收到服务端的FIN报文后，会发送一个ACK报文给服务端，然后进入TIME-WAIT状态。这个状态会持续一段时间（通常是2倍的数据传输的最长时间），以确保服务端能收到ACK报文。

f、服务端收到客户端的ACK报文后，就会关闭连接，进入CLOSED状态。当客户端的TIME-WAIT状态结束后，它也会关闭连接，进入CLOSED状态。

![image-20230922202105708](C:\Users\26926\AppData\Roaming\Typora\typora-user-images\image-20230922202105708.png)



<font color='#ff0000'> **为什么是四次挥手？而不是3次或5次挥手？**</font>

**(1)为什么不是3次挥手？**

首先要知道无论是挥手还是握手的过程中每次SYN或FIN请求都需要对方发送一个ACK包来确认的。假如客户端要求断开，那么客户端会发送一个FIN包，服务端收到后也会回复一个ACK包，表示确认收到。然后服务端同样需要发送一个FIN包给表示请求断开连接，客户端收到后也会回复一个ACK包来确认收到了。这就是4次挥手的过程。

如果说非要少一次挥手的话，可能会想，服务端发送ACK包和FIN包的时候不能放在同一个包中发出去吗？这样就可以减少一次挥手

但是实际上，服务端在收到客户端的FIN请求后，服务端还有一些未发完的数据需要发送给客户端，如果ACK和FIN包一起发，那就表示"我收到你断开连接的请求了，我这边也没有数据要发给你了，也要断开"。所以服务端的ACK包和FIN包需要分开发送，收到客户端的FIN包后，服务端先发一个ACK的包确认收到请求，等服务端的数据发完了再给客户端发送FIN包。

**(2)为什么不是5次挥手？**

可以但没有必要，浪费资源。

#### 4、通俗易懂理解TCP三次握手四次挥手

首选，弄懂3个标志位SYN、ACK、FIN的含义：SYN表示这个是一个建立连接的请求；ACK表示确认收到请求；FIN表示这是一个断开连接的请求。

TCP协议是一个双工协议，在建立连接的时候，客户端会先发送SYN包给服务端，表示希望建立连接。收到这个请求以后，服务端需要向客户端发送一个ACK包来确认它收到了这个请求，另外它还要发一个SYN包来表示自己想与客户端建立连接(双工协议)，所以它在收到服务端请求后，它会发给客户端一个SYN+ACK的包，客户端收到后再对这条消息进行确认，也就是客户端会再回一个SYN包。这就是TCP三次握手的过程。

至于TCP4次挥手，参考3次握手，在3次握手中服务端与客户端都发送了对方一个SYN包来建立一个双向的连接，那自然在断开的时候，双方都需要发一个FIN包来进行断开，发了FIN包对方自然要发一个ACK包确认收到。在3次握手中，服务端是SYN+ACK是一个包发的。而再四次挥手却是分成俩个包发的，这也就是为什么四次挥手要多一次的原因。当服务端收到客户端的断开连接请求后，服务端可能还存在着一些数据要发送给客户端，所以它不会立马发送FIN包给客户端，而是先发一个ACK包给客户端告诉他自己收到了客户端的断开连接请求，再数据发送之后，服务端再发送一个FIN包给客户端，然后客户端再回一个ACK包确认。这就是四次挥手的过程。

#### 5、sync半连接队列与accept全连接队列

什么是sync半连接队列？什么是accept全连接队列？

半连接队列，也叫SYN队列。服务端收到客户端发起的 SYN 请求后，**内核会把该连接存储到半连接队列**，并向客户端响应 SYN+ACK。

全连接队列，也叫accept 队列。当服务端收到客户端的ACK确认包后，就会将对应的连接从半连接队列中删除，然后创建**新的完全的连接，并将其添加到全连接队列中**，等待进程调用accept()将连接取出来。

<font color='#ff0000'> **不管是半连接队列还是全连接队列，都有最大长度限制，超过限制时，内核会直接丢弃，或返回 RST 包！**</font>这里会涉及到TCP内核参数的调优。

参考文章：

```
https://www.xiaolincoding.com/network/3_tcp/tcp_queue.html#%E5%AE%9E%E6%88%98-tcp-%E5%8D%8A%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97%E6%BA%A2%E5%87%BA
```

![image-20230923161340911](C:\Users\26926\AppData\Roaming\Typora\typora-user-images\image-20230923161340911.png)





### 四、ARP协议

#### 1、ARP协议的作用

ARP协议的作用是让主机可以通过其它同网段主机的IP地址来获取其MAC地址。

#### 2、ARP报文格式

以下是以太网帧头+ARP包的结构：

<img src="C:\Users\26926\AppData\Roaming\Typora\typora-user-images\image-20230915174731633.png" alt="image-20230915174731633" style="zoom:80%;" />



<img src="https://img-blog.csdnimg.cn/f159ccd081ec4eb1b008e1184b249ddb.png" alt="img" style="zoom: 67%;" />

这里需要注意几个问题：

(1)ARP报文封装成的帧，里面有2个源MAC地址和目标MAC地址，是不是重复了？为什么需要2个呢？

ARP报文想要在数据链路层进行传输，就必须封装成帧，也就是加一个以太网帧头。以太网帧头封装了3个部分：源MAC地址、目标MAC地址、帧类型。其中目标MAC地址为ff:ff:ff:ff:ff:ff，这是一个MAC的广播地址，所以ARP数据包会被发给同网段的所有主机；而帧类型是ARP，则告诉这些主机以何种方式来解析这个ARP请求报文。

而ARP请求报文的目标MAC地址为00:00:00:00:00:00，这是因为目标MAC地址是未知的，所以在ARP的请求报文中，目标MAC地址被设置为全0。在主机解析完ARP的请求报文后，如果自己的IP符合请求报文中的目标IP，那么它会将自己的MAC地址封装到ARP回复报文中，再封装为帧传输到对应的主机并将对方的源MAC地址和源IP地址做映射存在本地的ARP表中。

至于帧头的源MAC地址和ARP包的源MAC地址，首先帧头的源MAC地址是不可以缺少的，它要告诉同网段的主机以及交换机自己是谁。站在技术的角度，确实可以不通过获取ARP报文里面的源MAC地址而通过帧头的源MAC地址来获取，但是这是存在缺陷的，因为帧头的源MAC地址可能不是源主机的MAC，帧在经过某些网络设备的时候来源MAC地址可能会被改掉。而且，最重要的是，包括在存ARP缓存表以及回包的目标MAC地址都是通过ARP报文里面的源MAC地址来获取的，设计就是这么设计的，所以ARP报文里面的源MAC地址是不可缺少的一部分。

#### 3、ARP工作原理

我们知道了目标主机的ip地址，想和它通信，我们就发送一个ARP请求报文，将ARP请求报文封装为帧，帧头封装了3字段：源MAC地址、目标MAC地址、帧类型。其中目标MAC地址为ff:ff:ff:ff:ff:ff，这是一个MAC的广播地址，所以ARP数据包会被发给同网段的所有主机；而帧类型是ARP，则告诉这些主机以何种方式来解析这个ARP请求报文。各主机解析ARP报文后，如果发现自己的IP和目标IP一样，那么目标主机就会reply一个ARP回复报文(同样封装为帧)，告诉想和它通信的主机自己的MAC地址。然后目标主机的IP地址和MAC地址都会被写入到本机的ARP缓存表里面，后续如果还需要和目标主机通信，那不就不用再去ARP解析了。当然，ARP缓存表的表项是有老化时间的，一般5~20分钟。过了老化时间就需要从新发送arp请求去获取mac地址。



3、同网段主机通信

同网段的通信实际上是依赖交换机来实现的，而ARP的作用仅仅是帮助我们找到目标主机的MAC地址。

RARP



五、HTTP协议







六、HTTPS协议

tls握手过程

第一次握手：客户端发送一个“ClientHello”消息给服务器，开始TLS握手。这个消息包含客户端支持的TLS版本、密码套件，以及一个客户端生成的随机数。

第二次握手：服务器响应一个“ServerHello”消息，选择一个共同的TLS版本和密码套件，并发送一个服务器生成的随机数。服务器接着发送自己的证书，以及其他关键信息，如服务器密钥交换消息。

第三次握手：客户端验证服务器的证书和密钥信息是否过期？是否是受信任的CA机构签发的？然后发送一个“ClientKeyExchange”消息，包含预主密钥信息。如果服务器要求客户端证书，客户端也会在这时发送。随后，客户端发送一个“ChangeCipherSpec”消息，并发送“Finished”消息，表明客户端部分握手完成，接下来的消息将使用协商的密钥和算法加密。

第四次握手：服务器接收到客户端的“ChangeCipherSpec”和“Finished”消息后，也发送一个“ChangeCipherSpec”消息，随后发送“Finished”消息。这标志着握手过程完成，双方已建立了一个安全的加密连接。

```bash
#tls详解
https://www.cloudflare.com/zh-cn/learning/ssl/what-happens-in-a-tls-handshake/
```

